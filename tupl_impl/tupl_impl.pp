#ifndef TUPL_PASS
/*
 SPDX-FileCopyrightText: 2024 The Lemuriad <wjwray@gmail.com>
 SPDX-License-Identifier: BSL-1.0
 Repo: https://github.com/Lemuriad/tupl
*/
#if 0
     tupl_impl.pp -> tupl_impl.hpp preprocessing stage

  A tupl implementation tupl_impl.hpp is generated by preprocessing
  this file using the IREPEAT library to expand tuple-arity repetitions
  [0 .. tupl_max_arity) and each tupl member element within that arity.
  Preprocessing proceeds in three passes, TUPL_PASS symbol = empty,1,2.

  The resulting output tupl_impl.hpp implementation header depends on a
  prior #include "c_array_compare.hpp" - see tupl.hpp for setup required;
  symbols UNREACHABLE and NUA remain in the preprocessed output, for
  platform-specific handling of unreachable(), no_unique_address, etc.
*/
#endif

#include "IREPEAT.hpp"

#include "tupl_impl_noedit_warn.hpp" // Warning banner "generated file!"

#ifndef TUPL_MAX_ARITY /* the maximum number of elements specified as
                          parenthesized hex digits so (1)(0) == 16 */
#define TUPL_MAX_ARITY (1)(0)
#endif

//
inline constexpr size_t tupl_max_arity = HEXLIT(TUPL_MAX_ARITY);

#include "tupl_impl_forward_decls.hpp"

#define TUPL_TYPE_ID XD
#define TUPL_DATA_ID xD
#define MEMBER_DECL(D) TUPL_TYPE_ID(D) TUPL_DATA_ID(D);

#define TUPL_PASS 1
//
// tupl<T...> specializations VREPEATed for each arity
#define TUPL_ID tupl
#define VREPEAT_COUNT TUPL_MAX_ARITY
#define VREPEAT_MACRO tupl_impl.pp
#include "VREPEAT.hpp"
#undef TUPL_ID
#undef NUA
//
// lupl<T...> specializations VREPEATed for each arity
#if !defined(NO_LUPL) // conditionally don't generate lupl
#define NUA
#define TUPL_ID lupl
#define VREPEAT_COUNT TUPL_MAX_ARITY
#define VREPEAT_MACRO tupl_impl.pp
#include "VREPEAT.hpp"
#undef TUPL_ID
#undef NUA
#endif

#undef TUPL_PASS
#define TUPL_PASS 2
#include "tupl_impl.pp"

#elif (TUPL_PASS == 1) // Repeat this section for each arity

#if NREPEAT == 0
#define NZREPEAT(...)
#define MAYBE_UNUSED0()[[maybe_unused]]
#else
#define NZREPEAT(...)__VA_ARGS__
#define MAYBE_UNUSED0()
#endif

#define  MEMBER_ACCESSES(t) XREPEAT(VREPEAT_INDEX,t.TUPL_DATA_ID,COMMA)

//
template <XREPEAT(VREPEAT_INDEX,class TUPL_TYPE_ID,COMMA)>
struct TUPL_ID<XREPEAT(VREPEAT_INDEX,TUPL_TYPE_ID,COMMA)>
{
 using tupl_t = TUPL_ID;
 //
 XREPEAT(VREPEAT_INDEX,NUA MEMBER_DECL,NOSEP)
 //
 friend auto operator<=>(TUPL_ID const&,TUPL_ID const&)
  NZREPEAT(requires types_all<is_member_default_3way,TUPL_ID>)= default;
 //
 template <same_ish<TUPL_ID> T, typename F>
 friend constexpr decltype(auto) map(MAYBE_UNUSED0()T& t, F f)noexcept(
  noexcept(f( MEMBER_ACCESSES(t))))
  { return f( MEMBER_ACCESSES(t)); }
};

#undef  MEMBER_ACCESSES
#undef MAYBE_UNUSED0
#undef NZREPEAT

#else // TUPL_PASS == 2

#include "tupl_impl_getters.hpp"
#include "tupl_impl_assign.hpp"
#include "tupl_impl_compare.hpp"

#include "IREPEAT_UNDEF.hpp"

#undef MAP_IMPL

#undef MEMBER_DECL
#undef TUPL_DATA_ID
#undef TUPL_TYPE_ID

#undef TUPL_MAX_ARITY

#undef TUPL_PASS

#endif
